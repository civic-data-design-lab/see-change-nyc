const dataset = d3.csv("./data/heat-vulnerability-index.csv")
	.then(function(data) {
		data.forEach(function(d) {
			boroCD: +d.boroCD;
			cdName: d.cdName;
			borough: d.borough;
			temp: +d.temp;
			tempScaled: +d.tempScaled;
			veg: +d.veg;
			vegScaled: +d.vegScaled;
			poverty: +d.poverty;
			povertyScaled: +d.povertyScaled;
			black: +d.black;
			blackScaled: +d.blackScaled;
			ac: +d.ac;
			acScaled: +d.acScaled;
			hvi: +d.hvi;
		});

		if (!keys.length) {
			keys = data.columns;
		};
		if (!features.length) {
			features = data.columns.slice(3);
		};
		if (!featuresScaled.length) {
			featuresScaled = features.filter((item) => item.endsWith("Scaled"));
		}
		if (!compareFeatures.length) {
			compareFeatures = featuresScaled.concat(["hvi"]);
		}

		// store data to be sorted via click function
		if (!districtData.length) {
			districtData = data;
		}

		// data for borough average
		const distinct = (value, index, self) => {
			return self.indexOf(value) === index;
		};

		// borough list
		boroughList = data.map(function(item) {	return item.borough})
			.filter(distinct);

		for (var b = 0; b < boroughList.length; b++) {
			let borough = boroughList[b];
			item = {};

			for (var i = 0; i < features.length; i++) {
				let property = features[i];
				totalBorough = data.filter(d => d.borough == borough).reduce((accumulator, value) => (accumulator + +value[property]), 0);
				neighborhoodsPerBorough = data.filter(d => d.borough == borough).length;
				(borough == "Manhattan") ? (item.boroCD = "100")
					: (borough == "Bronx") ? (item.boroCD = "200")
					: (borough == "Brooklyn") ? (item.boroCD = "300")
					: (borough == "Queens") ? (item.boroCD = "400")
					: (borough == "Staten Island") ? (item.boroCD = "500")
					: item.boroCD = undefined;
				item.neighborhoods = neighborhoodsPerBorough;
				item.borough = borough;
				item[property] = totalBorough/neighborhoodsPerBorough;
				if (property.endsWith("Scaled") || property == "hvi") {
					item[property] = Math.round(item[property]);
				} else {
					item[property] = roundAccurately(item[property], 1);
				}
			};
			boroughAverage.push(item);
		};

		// profile data on load
		profileData = [data[26], data[6]];

		// sorted data on load
		allData = boroughAverage.sort((a,z) => d3.ascending(a.borough, z.borough))
				.sort((a, z) => d3.descending(a.hvi, z.hvi))
			.concat(data.sort((a, z) => d3.ascending(a.cdName, z.cdName))
				.sort((a, z) => d3.ascending(a.borough, z.borough))
				.sort((a, z) => d3.descending(a.hvi, z.hvi))
			);
		filteredData = allData;

		// plot data & display on load
		plotAllData(filteredData);

		// compareProfiles(profileData);
		plotProfiles(profileData);
		getProfileFeatureData(profileData);
		plotProfileFeatures(profileFeatureData);

		console.log(data);
		console.log(boroughAverage);
		console.log(compareFeatures);
	});

// aspect ratio
const width = 950;
const rowHeight = 24;
const profileRowHeight = 3.5 * rowHeight;
const labelOffset = 125;
const hexOffset = 400;

var winHeight = $(window).height();

// define svg
const svg = d3.select("#hvi-data")
	.append("svg")
		.attr("id", "hvi-chart")
		// .attr("class", "hvi-chart")

const svgProfile = d3.select("#hvi-profile")
	.append("svg")
		.attr("id", "svg-profiles")
		.attr("viewBox", [0, 0 - rowHeight/2, width, profileRowHeight * 2 - rowHeight])

// tooltip
var div = d3.select("body").append("div")
	.attr("id", "tooltip")
	.style("display", "none")
	.style('z-index', '10')
	.text("info");

// manipulated datasets
let keys = [];
let features = [];
let featuresScaled = [];
let compareFeatures = [];
let categories = ["Surface Temperature", "Vegetation Cover", "Non-Latinx Black Pop.", "People in Poverty", "No Access to Air Conditioner", "Heat Vulnerability"];

let boroughList = [];
let boroughAverage = [];
let districtData = [];
// data for profile highligh
let profileData = [];
let profileFeatureData = [];
// sorted & filtered data
let currentProperty = "hvi";
let currentBorough = "nyc";
let allData = [];
let filteredData = [];

// colors
const featureColor = d3.scaleOrdinal()
	.domain(categories)
	.range(["#dcc651", "#2d7f64", "#424d9b", "#8f2e62", "#f05d43", "#000000"])
	.unknown("#444444");

// round accurately function
function roundAccurately(number, decimalPlaces) {
	return Number(Math.round(number + "e" + decimalPlaces) + "e-" + decimalPlaces);	
};

// title case
function titleCase(string) {
	string = string.toLowerCase();
	string = string.split(' ');
	for (var i = 0; i < string.length; i++) {
		string[i] = string[i].charAt(0).toUpperCase() + string[i].slice(1);
	}
	return string.join(' ');
}

// wrap multi-line text spans
function wrapText(text, width) {
	text.each(function() {
		var text = d3.select(this),
			words = text.text().split(/\s+/).reverse(),
			word,
			line = [],
			lineNumber = 0,
			lineHeight = 1.2,
			anchor = text.attr("text-anchor"),
			x = text.attr("x"),
			y = text.attr("y"),
			dy = parseFloat(text.attr("dy")),
			tspan = text.text(null)
				.append("tspan")
				.attr("text-anchor", anchor)
				.attr("x", x)
				.attr("y", y)
				.attr("dy", dy + "em");
		while (word = words.pop()) {
			line.push(word);
			tspan.text(line.join(" "));
			if (tspan.node().getComputedTextLength() > width) {
				line.pop();
				tspan.text(line.join(" "));
				line = [word];
				tspan = text.append("tspan")
					.attr("text-anchor", anchor)
					.attr("x", x)
					.attr("y", y)
					.attr("dy", ++lineNumber * lineHeight + dy + "em")
					.text(word);
			}
		}
	})
}

// tooltip info per datapoint
function datapointTooltip(d) {
	return (d.feature == "temp") ? d[d.feature] + "&deg;F&ensp;Surface Temperature"
	: (d.feature == "veg") ? d[d.feature] + "%&ensp;Vegetation Cover"
	: (d.feature == "black") ? d[d.feature] + "%&ensp;Non-Latinx Black Pop."
	: (d.feature == "poverty") ? d[d.feature] + "%&ensp;People in Poverty"
	: (d.feature == "ac") ? d[d.feature] + "%&ensp;No Access to Air Conditioner"
	: "";
}

function getProfileFeatureData() {
	let newProfileFeatureData = [];
	for (var i = 0; i < compareFeatures.length; i++) {
		featureObj = {};
		if (compareFeatures[i] == "hvi") {
			var featureName = compareFeatures[i];
		} else {
			var featureName = compareFeatures[i].slice(0, -6);
		}
		// var featureDifference = roundAccurately((profileData[0][featureName] - profileData[1][featureName]), 1);
		var featureDifference = profileData[0][compareFeatures[i]] - profileData[1][compareFeatures[i]];

		featureObj.feature = featureName;
		featureObj.featureLabel = categories[i];
		featureObj.differenceValue = featureDifference;

		if (featureName == "temp") {
			featureObj.unit = "&deg;F"
		} else if (featureName == "hvi") {
			featureObj.unit = "";
		} else {
			featureObj.unit = "%"
		}

		if (featureDifference > 0) {
			featureObj.arrowImg = "arrow-more.svg";
			featureObj.differenceWord = "higher";
		} else if (featureDifference == 0) {
			featureObj.arrowImg = "arrow-same.svg";
			featureObj.differenceWord = "same";
		} else if (featureDifference < 0) {
			featureObj.arrowImg = "arrow-less.svg";
			featureObj.differenceWord = "lower";
		}

		newProfileFeatureData.push(featureObj);
	}
	profileFeatureData = newProfileFeatureData;
}

// draw hexagon row
const hexRadius = 10;
var hexbin = d3.hexbin()
	.radius(hexRadius);

function getHexCoordinates(dataPoint) {
	var points = [];
	for (var i = 0; i < (featuresScaled.length * 5); i++) {
			if (i < 5) {
				var f = 0;
			} else if (i < 10) {
				var f = 1;
			} else if (i < 15) {
				var f = 2;
			} else if (i < 20) {
				var f = 3;
			} else {
				var f = 4;
			}
			let featureName = featuresScaled[f].slice(0, -6);
			let featureScaled = featuresScaled[f];

			let item = [];
			// center position of each hexagon
			item.x = hexOffset + i * hexRadius * Math.sqrt(3);
			item.y = rowHeight/2;
			// add data for tooltip
			item.feature = featureName;
			item[featureName] = dataPoint[featureName];
			item[featureScaled] = dataPoint[featureScaled];
			item.boroCD = dataPoint.boroCD;
			item.cdName = dataPoint.cdName;
			item.borough = dataPoint.borough;
			if ((i - f*5) < dataPoint[featureScaled]) {
				item.fill = featureColor(categories[f]);
			} else {
				item.fill = "#fff";
			}

			points.push(item);
	};
	return points;
}

function plotHexagons(dataRow, data, yPosMultiplier) {
	let hexData = getHexCoordinates(data);

	dataRow.append("g")
			.attr("class", "hex-row")
		.selectAll("path")
		.data(hexData)
		.enter()
		.append("path")
			.attr("class", (d) => "hexagon-" + d.boroCD)
			.attr("d", (d) => {
				return "M" + d.x  + "," + (d.y + yPosMultiplier) + hexbin.hexagon();
			})
			.attr("stroke", "#000")
			.attr("stroke-width", "1px")
			.style("fill", (d) => d.fill)
};

function plotProfiles(data) {
	for (var i = 0; i < data.length; i++) {
		let chartID = "#proflechart" + profileData[i].boroCD;
		let rowData = [profileData[i]];

		const dataRow = svgProfile.append("g")
			.attr("id", "profilechart" + profileData[i].boroCD)

		plotHexagons(dataRow, profileData[i], (profileRowHeight * i));

		dataRow.selectAll("text.profile-place")
			.data(rowData)
			.enter()
			.append("text")
				.attr("class", "profile-place")
				.text((d) => {
					if (d.borough == "Bronx") {var boroughAbbr = "BX";}
					else if (d.borough == "Brooklyn") {var boroughAbbr = "BK";}
					else if (d.borough == "Manhattan") {var boroughAbbr = "MN";}
					else if (d.borough == "Queens") {var boroughAbbr = "QN";}
					else if (d.borough == "Staten Island") {var boroughAbbr = "SI";}

					return (!d.cdName) ? d.borough
					: d.cdName + ", " + boroughAbbr;
				})
				.attr("text-anchor", "end")
				.attr("x", hexOffset - 2 * hexRadius)
				.attr("y", profileRowHeight * i + rowHeight - 4)
				.attr("dy", 0)
				.call(wrapText, hexOffset - (10 * hexRadius))

		dataRow.selectAll("text.profile-hvi")
			.data(rowData)
			.enter()
			.append("text")
				.attr("class", "profile-hvi")
				.text((d) => {
					return (!d.cdName) ? "= " + d.hvi + " Avg. HVI"
					: "= " + d.hvi + " HVI"
				})
				.attr("text-anchor", "start")
				.attr("x", hexOffset + 44 * hexRadius)
				.attr("y", (profileRowHeight * i) + rowHeight - 4)

		// dataRow.selectAll("text.profile-hvi-word")
		// 	.data(rowData)
		// 	.enter()
		// 	.append("text")
		// 		.attr("class", "profile-hvi-word")
		// 		.text((d) => {
		// 			if (d.hvi == 1) {var hviWord = "low";}
		// 			else if (d.hvi == 2) {var hviWord = "med-low";}
		// 			else if (d.hvi == 3) {var hviWord = "med";}
		// 			else if (d.hvi == 4) {var hviWord = "med-high";}
		// 			else if (d.hvi == 5) {var hviWord = "high";}
		// 			return hviWord + " HVI";
		// 		})
		// 		.attr("text-anchor", "middle")
		// 		.attr("x", hexOffset + 48 * hexRadius)
		// 		.attr("y", profileRowHeight * i + (1.5 * rowHeight) + 7)

		// hover data
		dataRow.select(".hex-row")
			.selectAll("path")
			.on("mouseover", function(event, d) {
				div.html((divHtml) => datapointTooltip(d))
					.style("color", "#000")
					// .style("color", (divHtml) => featureColor(datapointTooltip(d.feature)))
					.style("display", "block")
			})
			.on("mousemove", function(event) {
				div.style("top", (divHtml) => {
						var divY = event.pageY;
						var tooltipHeight = $("#tooltip").outerHeight();
						var displayHeight = $("#hvi-data").height();
						if ((divY - winHeight + tooltipHeight) > displayHeight) {
							divY = divY - tooltipHeight - 10;
						};
						return (divY + 10) + "px"
					})
					.style("left", (divHtml) => {
						var divX = event.pageX;
						var tooltipWidth = $("#tooltip").outerWidth();
						var displayWidth = $(window).width();
						if ((divX + tooltipWidth) > displayWidth) {
							divX = divX - tooltipWidth - 10;
						};
						return (divX + 10) + "px"
					})
			})
			.on("mouseout", function() {
				div.style("display", "none");
			})
	}
}

function plotProfileFeatures() {
	const profileFeatures = svgProfile.append("g")
		.attr("id", "profile-features")

	profileFeatures.append("g")
			.attr("class", "feature-arrow")
		.selectAll("image")
		.data(profileFeatureData)
		.enter()
		.append("svg:image")
			.attr("id", (d) => "feature-" + d.feature)
			.attr("xlink:href", (d) => "./img/heat-vulnerability/" + d.arrowImg)
			.attr("x", (d, i) => {
				return (d.feature == "hvi") ? hexOffset + 45 * hexRadius
				: hexOffset + (8.625 * hexRadius * i) - hexRadius/2;
			})
			.attr("y", profileRowHeight/2 - 2)
			.attr("width",  hexRadius)
			.attr("height", 3 * hexRadius)

	profileFeatures.append("g")
			.attr("class", "feature-difference")
		.selectAll("text")
		.data(profileFeatureData)
		.enter()
		.append("text")
			.attr("id", (d) => "feature-" + d.feature)
			// .html((d) => d.differenceValue + d.unit + " " + d.differenceWord)
			.text((d) => d.differenceWord)
			.attr("text-anchor", "start")
			.attr("x", (d, i) => {
				return (d.feature == "hvi") ? hexOffset + 46.25 * hexRadius
				: hexOffset + (8.625 * hexRadius * i) + (0.75 * hexRadius);
			})
			.attr("y", profileRowHeight/2 + (0.5 * rowHeight) - 7)

	profileFeatures.append("g")
			.attr("class", "label-feature")
		.selectAll("text")
		.data(profileFeatureData)
		.enter()
		.append("text")
			.attr("id", (d) => "feature-" + d.feature)
			.text((d) => d.featureLabel)
			.attr("text-anchor", "start")
			.attr("x", (d, i) => {
				return (d.feature == "hvi") ? hexOffset + 46.25 * hexRadius
				: hexOffset + (8.625 * hexRadius * i) + (0.75 * hexRadius);
			})
			.attr("y", profileRowHeight/2 + (0.5 * rowHeight) + 4)
			.attr("dy", 0)
			.attr("fill", (d) => featureColor(d.featureLabel))
			.call(wrapText, (9 * hexRadius))
}

function plotAllData(data) {
	svg.attr("viewBox", [0, 0, width, rowHeight * data.length])

	for (var i = 0; i < data.length; i++) {
		let chartID = "#chart" + data[i].boroCD;
		let rowData = [data[i]];

		const dataRow = svg.append("g")
			.attr("id", "chart" + data[i].boroCD)

		dataRow.selectAll("rect")
			.data(rowData)
			.enter()
			.append("rect")
				.attr("x", 0)
				.attr("y", (rowHeight * i))
				.attr("width", width)
				.attr("height", rowHeight)
				.attr("fill", "#d1d3d4")
				.attr("opacity", (d) => {
					return (d.boroCD == profileData[0].boroCD || d.boroCD == profileData[1].boroCD) ? 1
					: 0;
				})
			.on("click", function(event, d) {
					var clickedData = allData.filter((data) => data.boroCD == d.boroCD);
					profileData.shift();
					profileData = profileData.concat(clickedData);
					compareProfiles(profileData);
			})

		plotHexagons(dataRow, data[i], (rowHeight * i));
		
		dataRow.selectAll("text.labelplace")
			.data(rowData)
			.enter()
			.append("text")
				.attr("class", "labelplace")
				.text((d) => {
					return (!d.cdName) ? d.borough
					: (d.borough == "Bronx") ? d.cdName + ", BX"
					: (d.borough == "Brooklyn") ? d.cdName + ", BK"
					: (d.borough == "Manhattan") ? d.cdName + ", MN"
					: (d.borough == "Queens") ? d.cdName + ", QN"
					: (d.borough == "Staten Island") ? d.cdName + ", SI"
					: d.cdName;
				})
				.attr("text-anchor", "end")
				.attr("x", hexOffset - 25)
				.attr("y", (rowHeight * (i + 1)) - 7)

		dataRow.selectAll("text.labelhviscore")
			.data(rowData)
			.enter()		
			.append("text")
				.attr("class", "labelhviscore")
				.text((d) => {
					return (!d.cdName) ? "= " + d.hvi + " Avg. HVI"
					: "= " + d.hvi + " HVI"
				})
				.attr("text-anchor", "start")
				.attr("x", hexOffset + 44 * hexRadius)
				.attr("y", (rowHeight * (i + 1)) - 7)

		dataRow.selectAll("text")
			.on("click", function(event, d) {
					var clickedData = allData.filter((data) => data.boroCD == d.boroCD);
					profileData.shift();
					profileData = profileData.concat(clickedData);
					compareProfiles(profileData);
			})

		// hover data
		dataRow.select(".hex-row")
			.selectAll("path")
			.on("mouseover", function(event, d) {
				div.html((divHtml) => datapointTooltip(d))
					.style("color", "#000")
					// .style("color", (divHtml) => featureColor(datapointTooltip(d.feature)))
					.style("display", "block")
			})
			.on("mousemove", function(event) {
				div.style("top", (divHtml) => {
						var divY = event.pageY;
						var tooltipHeight = $("#tooltip").outerHeight();
						if ((divY - winHeight + tooltipHeight) > winHeight) {
							divY = divY - tooltipHeight - 10;
						};
						return (divY + 10) + "px"
					})
					.style("left", (divHtml) => {
						var divX = event.pageX;
						var tooltipWidth = $("#tooltip").outerWidth();
						var displayWidth = $(window).width();
						if ((divX + tooltipWidth) > displayWidth) {
							divX = divX - tooltipWidth - 10;
						};
						return (divX + 10) + "px"
					})
			})
			.on("mouseout", function() {
				div.style("display", "none");
			})
			.on("click", function(event, d) {
					var clickedData = allData.filter((data) => data.boroCD == d.boroCD);
					profileData.shift();
					profileData = profileData.concat(clickedData);
					compareProfiles(profileData);
			})
	}
}

// animation duration
const animationDuration = 1000;

function hideOldProfileData(profileData) {

}

// compare profile data
function compareProfiles(profileData) {
	// update profile charts
	for (var i = 0; i < allData.length; i++) {
		let chartID = "#profilechart" + allData[i].boroCD;
		let rowData = [allData[i]];

		const dataRow = svgProfile.select(chartID);
		let hexData = getHexCoordinates(allData[i]);

		dataRow.remove();
	}
	plotProfiles(profileData);

	// update profile features
	svgProfile.select("#profile-features")
		.remove();

	getProfileFeatureData();
	plotProfileFeatures();

	// update rectangle background fill
	for (var i = 0; i < filteredData.length; i++) {
		let chartID = "#chart" + filteredData[i].boroCD;
		let rowData = [filteredData[i]];

		const dataRow = svg.select(chartID);

		dataRow.selectAll("rect")
			.data(rowData)
				.transition()
				.duration(animationDuration/2)
				.attr("y", (rowHeight * i))
				.attr("opacity", (d) => {
					return (d.boroCD == profileData[0].boroCD || d.boroCD == profileData[1].boroCD) ? 1
					: 0;
				})
	}
};

// sort data by property
function sortData(property) {
	return (property == "place") ? allData = boroughAverage.sort((a,z) => d3.ascending(a.borough, z.borough))
			.concat(districtData.sort((a, z) => d3.ascending(a.cdName, z.cdName))
				.sort((a,z) => d3.ascending(a.borough, z.borough)))
	: (property == "hvi") ?	allData = boroughAverage.sort((a,z) => d3.ascending(a.borough, z.borough))
				.sort((a, z) => d3.descending(+a.hvi, +z.hvi))
			.concat(districtData.sort((a, z) => d3.ascending(a.cdName, z.cdName))
				.sort((a, z) => d3.ascending(a.borough, z.borough))
				.sort((a, z) => d3.descending(+a.hvi, +z.hvi)))
	: allData = boroughAverage.sort((a, z) => d3.descending(+a[property], +z[property]))
			.concat(districtData.sort((a, z) => d3.descending(+a[property], +z[property])));
}

// filter data by borough
function filterData(borough) {
	return (borough == "nyc") ? filteredData = allData
	: (borough == "Statenisland") ? allData.filter((d) => d.borough == "Staten Island")
	: filteredData = allData.filter((d) => d.borough == borough);
}

// update plotted data
function updatePlottedData() {
	svg.attr("viewBox", [0, 0, width, rowHeight * filteredData.length])

	for (var i = 0; i < filteredData.length; i++) {
		let chartID = "#chart" + filteredData[i].boroCD;
		let rowData = [filteredData[i]];

		const dataRow = svg.select(chartID);
		let hexData = getHexCoordinates(filteredData[i]);

		dataRow.selectAll("rect")
			.data(rowData)
				.transition()
				.duration(animationDuration)
				.attr("y", (rowHeight * i))
				.attr("opacity", (d) => {
					return (d.boroCD == profileData[0].boroCD || d.boroCD == profileData[1].boroCD) ? 1
					: 0;
				})

		dataRow.select(".hex-row")
			.selectAll("path")
			.data(hexData)
				.transition()
				.ease(d3.easeCubic)
				.duration(animationDuration)
				.attr("d", (d) => {
					return "M" + d.x  + "," + (d.y + (rowHeight * i)) + hexbin.hexagon();
				})
		
		dataRow.selectAll("text.labelplace")
			.data(rowData)
				.transition()
				.ease(d3.easeCubic)
				.duration(animationDuration)
				.attr("y", (rowHeight * (i + 1)) - 7)

		dataRow.selectAll("text.labelhviscore")
			.data(rowData)
				.transition()
				.ease(d3.easeCubic)
				.duration(animationDuration)
				.attr("y", (rowHeight * (i + 1)) - 7)
	}
}

// sort data on click
function showSortedData(property) {
	sortData(property);
	filterData(currentBorough);
	updatePlottedData();
}

// filter data by borough
function showFilteredData(boroughId) {
	if (boroughId == "nyc") {
		currentBorough = "nyc";
	} else if (boroughId == "statenisland") {
		currentBorough = "Staten Island";
	} else {
		currentBorough = titleCase(boroughId);
	}
	// console.log(currentBorough);
	
	sortData(currentProperty);
	filterData(currentBorough);

	for (var i = 0; i < allData.length; i++) {
		let chartID = "#chart" + allData[i].boroCD;
		let rowData = [allData[i]];

		const dataRow = svg.select(chartID);
		let hexData = getHexCoordinates(allData[i]);

		if (!filteredData.includes(allData[i])) {
			dataRow.attr("visibility", "hidden");
		}
		else {
			dataRow.attr("visibility", "visible");
		}
	}

	updatePlottedData();

}

// display on load
$(document).ready(function(){
	$("#nav>ul>li>ul>li").addClass("grey");
	$("#hvi").addClass("sorted-feature").css("background", "#fff").css("color", "#000").css("border-color", "#000");
})

// nav borough filter display
function filterBoroughNav(boroughId) {
	$("#city").addClass("grey").css("color", "#d1d3d4");
	$("#borough").removeClass("grey").css("color", "#000");

	$("#nav>ul>li>ul>li").addClass("grey").css("color", "#d1d3d4");
	$("#" + boroughId).removeClass("grey").css("color", "#000");
	if (boroughId == "nyc") {
		$("#currentborough").html("&mdash;All");
	} else if (boroughId == "statenisland") {
		$("#currentborough").html("&mdash;Staten Island");
	}
	else {
		$("#currentborough").html("&mdash;" + titleCase(boroughId));
	}
}

// nav clicks
$("#city").on("click", function() {
	$(this).removeClass("grey").css("color", "#000");
	$("#borough").addClass("grey").css("color", "#d1d3d4");

	$("#nav>ul>li>ul>li").addClass("grey").css("color", "#d1d3d4");
	$("#currentborough").html("");


});
$("#borough").on("click", function() {
	$(this).removeClass("grey").css("color", "#000");
	$("#city").addClass("grey").css("color", "#d1d3d4");

	$("#nav>ul>li>ul>li").addClass("grey").css("color", "#d1d3d4");
	$("#nyc").removeClass("grey").css("color", "#000");
	$("#currentborough").html("&mdash;All");

});
// nav click by filtering boroughs
$("#nav>ul>li>ul>li").on("click", function() {
	filterBoroughNav($(this).attr("id"));
	showFilteredData($(this).attr("id"));

	// let chartBoroughClass = ".chart" + $(this).attr("id");
	// $(chartBoroughClass).css("display", "block");
})

// sort data by property
$(".sort-button").on("click", function(e) {
	if (!$(this).hasClass("sorted-feature")) {
		$(".sorted-feature").removeClass("sorted-feature").css("background", "#d1d3d4").css("border-color", "#d1d3d4").css("color", "#333");
		$(this).addClass("sorted-feature").css("background", "#fff").css("border-color", "#000").css("color", "#000");

		showSortedData($(this).attr("id"));
	}
});
$(".sort-button").on("mouseover", function() {
	if ($(this).hasClass("sorted-feature")) {
		$(this).css("background", "#fff").css("border-color", "#000").css("color", "#000");
	}
	else {
		$(this).css("background", "#8c8c8c").css("border-color", "#8c8c8c").css("color", "#000");
	}
});
$(".sort-button").on("mouseleave", function() {
	if ($(this).hasClass("sorted-feature")) {
		$(this).css("background", "#fff").css("border-color", "#000").css("color", "#000");
	}
	else {
		$(this).css("background", "#d1d3d4").css("border-color", "#d1d3d4").css("color", "#333");
	}
});